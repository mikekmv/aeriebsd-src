


PEM_READ_BIO_PRIVATEKEY(3)   OpenSSL   PEM_READ_BIO_PRIVATEKEY(3)


NNAAMMEE
       PEM - PEM routines

SSYYNNOOPPSSIISS
        #include <openssl/pem.h>

        EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x,
                                               pem_password_cb *cb, void *u);

        EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x,
                                               pem_password_cb *cb, void *u);

        int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u);

        int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u);

        int PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                               char *kstr, int klen,
                                               pem_password_cb *cb, void *u);

        int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                               char *kstr, int klen,
                                               pem_password_cb *cb, void *u);

        int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,
                                               char *kstr, int klen,
                                               pem_password_cb *cb, void *u);

        int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,
                                               char *kstr, int klen,
                                               pem_password_cb *cb, void *u);

        EVP_PKEY *PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x,
                                               pem_password_cb *cb, void *u);

        EVP_PKEY *PEM_read_PUBKEY(FILE *fp, EVP_PKEY **x,
                                               pem_password_cb *cb, void *u);

        int PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x);
        int PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x);

        RSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **x,
                                               pem_password_cb *cb, void *u);

        RSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **x,
                                               pem_password_cb *cb, void *u);

        int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u);



AerieBSD 1.0                2009-05-26                          1





PEM_READ_BIO_PRIVATEKEY(3)   OpenSSL   PEM_READ_BIO_PRIVATEKEY(3)


        int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u);

        RSA *PEM_read_bio_RSAPublicKey(BIO *bp, RSA **x,
                                               pem_password_cb *cb, void *u);

        RSA *PEM_read_RSAPublicKey(FILE *fp, RSA **x,
                                               pem_password_cb *cb, void *u);

        int PEM_write_bio_RSAPublicKey(BIO *bp, RSA *x);

        int PEM_write_RSAPublicKey(FILE *fp, RSA *x);

        RSA *PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x,
                                               pem_password_cb *cb, void *u);

        RSA *PEM_read_RSA_PUBKEY(FILE *fp, RSA **x,
                                               pem_password_cb *cb, void *u);

        int PEM_write_bio_RSA_PUBKEY(BIO *bp, RSA *x);

        int PEM_write_RSA_PUBKEY(FILE *fp, RSA *x);

        DSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **x,
                                               pem_password_cb *cb, void *u);

        DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **x,
                                               pem_password_cb *cb, void *u);

        int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u);

        int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u);

        DSA *PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA **x,
                                               pem_password_cb *cb, void *u);

        DSA *PEM_read_DSA_PUBKEY(FILE *fp, DSA **x,
                                               pem_password_cb *cb, void *u);

        int PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x);

        int PEM_write_DSA_PUBKEY(FILE *fp, DSA *x);

        DSA *PEM_read_bio_DSAparams(BIO *bp, DSA **x, pem_password_cb *cb, void *u);

        DSA *PEM_read_DSAparams(FILE *fp, DSA **x, pem_password_cb *cb, void *u);

        int PEM_write_bio_DSAparams(BIO *bp, DSA *x);




AerieBSD 1.0                2009-05-26                          2





PEM_READ_BIO_PRIVATEKEY(3)   OpenSSL   PEM_READ_BIO_PRIVATEKEY(3)


        int PEM_write_DSAparams(FILE *fp, DSA *x);

        DH *PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u);

        DH *PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u);

        int PEM_write_bio_DHparams(BIO *bp, DH *x);

        int PEM_write_DHparams(FILE *fp, DH *x);

        X509 *PEM_read_bio_X509(BIO *bp, X509 **x, pem_password_cb *cb, void *u);

        X509 *PEM_read_X509(FILE *fp, X509 **x, pem_password_cb *cb, void *u);

        int PEM_write_bio_X509(BIO *bp, X509 *x);

        int PEM_write_X509(FILE *fp, X509 *x);

        X509 *PEM_read_bio_X509_AUX(BIO *bp, X509 **x, pem_password_cb *cb, void *u);

        X509 *PEM_read_X509_AUX(FILE *fp, X509 **x, pem_password_cb *cb, void *u);

        int PEM_write_bio_X509_AUX(BIO *bp, X509 *x);

        int PEM_write_X509_AUX(FILE *fp, X509 *x);

        X509_REQ *PEM_read_bio_X509_REQ(BIO *bp, X509_REQ **x,
                                               pem_password_cb *cb, void *u);

        X509_REQ *PEM_read_X509_REQ(FILE *fp, X509_REQ **x,
                                               pem_password_cb *cb, void *u);

        int PEM_write_bio_X509_REQ(BIO *bp, X509_REQ *x);

        int PEM_write_X509_REQ(FILE *fp, X509_REQ *x);

        int PEM_write_bio_X509_REQ_NEW(BIO *bp, X509_REQ *x);

        int PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x);

        X509_CRL *PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x,
                                               pem_password_cb *cb, void *u);
        X509_CRL *PEM_read_X509_CRL(FILE *fp, X509_CRL **x,
                                               pem_password_cb *cb, void *u);
        int PEM_write_bio_X509_CRL(BIO *bp, X509_CRL *x);
        int PEM_write_X509_CRL(FILE *fp, X509_CRL *x);

        PKCS7 *PEM_read_bio_PKCS7(BIO *bp, PKCS7 **x, pem_password_cb *cb, void *u);

        PKCS7 *PEM_read_PKCS7(FILE *fp, PKCS7 **x, pem_password_cb *cb, void *u);

        int PEM_write_bio_PKCS7(BIO *bp, PKCS7 *x);

        int PEM_write_PKCS7(FILE *fp, PKCS7 *x);



AerieBSD 1.0                2009-05-26                          3





PEM_READ_BIO_PRIVATEKEY(3)   OpenSSL   PEM_READ_BIO_PRIVATEKEY(3)


        NETSCAPE_CERT_SEQUENCE *PEM_read_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp,
                                                       NETSCAPE_CERT_SEQUENCE **x,
                                                       pem_password_cb *cb, void *u);

        NETSCAPE_CERT_SEQUENCE *PEM_read_NETSCAPE_CERT_SEQUENCE(FILE *fp,
                                                       NETSCAPE_CERT_SEQUENCE **x,
                                                       pem_password_cb *cb, void *u);

        int PEM_write_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp, NETSCAPE_CERT_SEQUENCE *x);

        int PEM_write_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE *x);

DDEESSCCRRIIPPTTIIOONN
       The PEM functions read or write structures in PEM format.
       In this sense PEM format is simply base64 encoded data
       surrounded by header lines.

       For more details about the meaning of arguments see the
       PPEEMM FFUUNNCCTTIIOONN AARRGGUUMMEENNTTSS section.

       Each operation has four functions associated with it. For
       clarity the term "ffoooobbaarr functions" will be used to col-
       lectively refer to the _P_E_M___r_e_a_d___b_i_o___f_o_o_b_a_r_(_),
       _P_E_M___r_e_a_d___f_o_o_b_a_r_(_), _P_E_M___w_r_i_t_e___b_i_o___f_o_o_b_a_r_(_) and
       _P_E_M___w_r_i_t_e___f_o_o_b_a_r_(_) functions.

       The PPrriivvaatteeKKeeyy functions read or write a private key in
       PEM format using an EVP_PKEY structure. The write routines
       use "traditional" private key format and can handle both
       RSA and DSA private keys. The read functions can addition-
       ally transparently handle PKCS#8 format encrypted and
       unencrypted keys too.

       _P_E_M___w_r_i_t_e___b_i_o___P_K_C_S_8_P_r_i_v_a_t_e_K_e_y_(_) and _P_E_M___w_r_i_t_e___P_K_C_S_8_P_r_i_-
       _v_a_t_e_K_e_y_(_) write a private key in an EVP_PKEY structure in
       PKCS#8 EncryptedPrivateKeyInfo format using PKCS#5 v2.0
       password based encryption algorithms. The cciipphheerr argument
       specifies the encryption algoritm to use: unlike all other
       PEM routines the encryption is applied at the PKCS#8 level
       and not in the PEM headers. If cciipphheerr is NULL then no
       encryption is used and a PKCS#8 PrivateKeyInfo structure
       is used instead.

       _P_E_M___w_r_i_t_e___b_i_o___P_K_C_S_8_P_r_i_v_a_t_e_K_e_y___n_i_d_(_) and
       _P_E_M___w_r_i_t_e___P_K_C_S_8_P_r_i_v_a_t_e_K_e_y___n_i_d_(_) also write out a private
       key as a PKCS#8 EncryptedPrivateKeyInfo however it uses
       PKCS#5 v1.5 or PKCS#12 encryption algorithms instead. The
       algorithm to use is specified in the nniidd parameter and
       should be the NID of the corresponding OBJECT IDENTIFIER
       (see NOTES section).

       The PPUUBBKKEEYY functions process a public key using an
       EVP_PKEY structure. The public key is encoded as a Sub-
       jectPublicKeyInfo structure.



AerieBSD 1.0                2009-05-26                          4





PEM_READ_BIO_PRIVATEKEY(3)   OpenSSL   PEM_READ_BIO_PRIVATEKEY(3)


       The RRSSAAPPrriivvaatteeKKeeyy functions process an RSA private key
       using an RSA structure. It handles the same formats as the
       PPrriivvaatteeKKeeyy functions but an error occurs if the private
       key is not RSA.

       The RRSSAAPPuubblliiccKKeeyy functions process an RSA public key using
       an RSA structure. The public key is encoded using a PKCS#1
       RSAPublicKey structure.

       The RRSSAA__PPUUBBKKEEYY functions also process an RSA public key
       using an RSA structure. However the public key is encoded
       using a SubjectPublicKeyInfo structure and an error occurs
       if the public key is not RSA.

       The DDSSAAPPrriivvaatteeKKeeyy functions process a DSA private key
       using a DSA structure. It handles the same formats as the
       PPrriivvaatteeKKeeyy functions but an error occurs if the private
       key is not DSA.

       The DDSSAA__PPUUBBKKEEYY functions process a DSA public key using a
       DSA structure. The public key is encoded using a Subject-
       PublicKeyInfo structure and an error occurs if the public
       key is not DSA.

       The DDSSAAppaarraammss functions process DSA parameters using a DSA
       structure. The parameters are encoded using a foobar
       structure.

       The DDHHppaarraammss functions process DH parameters using a DH
       structure. The parameters are encoded using a PKCS#3 DHpa-
       rameter structure.

       The XX550099 functions process an X509 certificate using an
       X509 structure. They will also process a trusted X509 cer-
       tificate but any trust settings are discarded.

       The XX550099__AAUUXX functions process a trusted X509 certificate
       using an X509 structure.

       The XX550099__RREEQQ and XX550099__RREEQQ__NNEEWW functions process a PKCS#10
       certificate request using an X509_REQ structure. The
       XX550099__RREEQQ write functions use CCEERRTTIIFFIICCAATTEE RREEQQUUEESSTT in the
       header whereas the XX550099__RREEQQ__NNEEWW functions use NNEEWW CCEERRTTIIFFII--
       CCAATTEE RREEQQUUEESSTT (as required by some CAs). The XX550099__RREEQQ read
       functions will handle either form so there are no
       XX550099__RREEQQ__NNEEWW read functions.

       The XX550099__CCRRLL functions process an X509 CRL using an
       X509_CRL structure.

       The PPKKCCSS77 functions process a PKCS#7 ContentInfo using a
       PKCS7 structure.

       The NNEETTSSCCAAPPEE__CCEERRTT__SSEEQQUUEENNCCEE functions process a Netscape



AerieBSD 1.0                2009-05-26                          5





PEM_READ_BIO_PRIVATEKEY(3)   OpenSSL   PEM_READ_BIO_PRIVATEKEY(3)


       Certificate Sequence using a NETSCAPE_CERT_SEQUENCE struc-
       ture.

PPEEMM FFUUNNCCTTIIOONN AARRGGUUMMEENNTTSS
       The PEM functions have many common arguments.

       The bbpp BIO parameter (if present) specifies the BIO to
       read from or write to.

       The ffpp FILE parameter (if present) specifies the FILE
       pointer to read from or write to.

       The PEM read functions all take an argument TTYYPPEE ****xx and
       return a TTYYPPEE ** pointer. Where TTYYPPEE is whatever structure
       the function uses. If xx is NULL then the parameter is
       ignored. If xx is not NULL but **xx is NULL then the struc-
       ture returned will be written to **xx. If neither xx nor **xx
       is NULL then an attempt is made to reuse the structure at
       **xx (but see BUGS and EXAMPLES sections).  Irrespective of
       the value of xx a pointer to the structure is always
       returned (or NULL if an error occurred).

       The PEM functions which write private keys take an eenncc
       parameter which specifies the encryption algorithm to use,
       encryption is done at the PEM level. If this parameter is
       set to NULL then the private key is written in unencrypted
       form.

       The ccbb argument is the callback to use when querying for
       the pass phrase used for encrypted PEM structures (nor-
       mally only private keys).

       For the PEM write routines if the kkssttrr parameter is not
       NULL then kklleenn bytes at kkssttrr are used as the passphrase
       and ccbb is ignored.

       If the ccbb parameters is set to NULL and the uu parameter is
       not NULL then the uu parameter is interpreted as a null
       terminated string to use as the passphrase. If both ccbb and
       uu are NULL then the default callback routine is used which
       will typically prompt for the passphrase on the current
       terminal with echoing turned off.

       The default passphrase callback is sometimes inappropriate
       (for example in a GUI application) so an alternative can
       be supplied. The callback routine has the following form:

        int cb(char *buf, int size, int rwflag, void *u);

       bbuuff is the buffer to write the passphrase to. ssiizzee is the
       maximum length of the passphrase (i.e. the size of buf).
       rrwwffllaagg is a flag which is set to 0 when reading and 1 when
       writing. A typical routine will ask the user to verify the
       passphrase (for example by prompting for it twice) if



AerieBSD 1.0                2009-05-26                          6





PEM_READ_BIO_PRIVATEKEY(3)   OpenSSL   PEM_READ_BIO_PRIVATEKEY(3)


       rrwwffllaagg is 1. The uu parameter has the same value as the uu
       parameter passed to the PEM routine. It allows arbitrary
       data to be passed to the callback by the application (for
       example a window handle in a GUI application). The call-
       back mmuusstt return the number of characters in the
       passphrase or 0 if an error occurred.

EEXXAAMMPPLLEESS
       Although the PEM routines take several arguments in almost
       all applications most of them are set to 0 or NULL.

       Read a certificate in PEM format from a BIO:

        X509 *x;
        x = PEM_read_bio_X509(bp, NULL, 0, NULL);
        if (x == NULL)
               {
               /* Error */
               }

       Alternative method:

        X509 *x = NULL;
        if (!PEM_read_bio_X509(bp, &x, 0, NULL))
               {
               /* Error */
               }

       Write a certificate to a BIO:

        if (!PEM_write_bio_X509(bp, x))
               {
               /* Error */
               }

       Write an unencrypted private key to a FILE pointer:

        if (!PEM_write_PrivateKey(fp, key, NULL, NULL, 0, 0, NULL))
               {
               /* Error */
               }

       Write a private key (using traditional format) to a BIO
       using triple DES encryption, the pass phrase is prompted
       for:

        if (!PEM_write_bio_PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, NULL))
               {
               /* Error */
               }

       Write a private key (using PKCS#8 format) to a BIO using
       triple DES encryption, using the pass phrase "hello":




AerieBSD 1.0                2009-05-26                          7





PEM_READ_BIO_PRIVATEKEY(3)   OpenSSL   PEM_READ_BIO_PRIVATEKEY(3)


        if (!PEM_write_bio_PKCS8PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, "hello"))
               {
               /* Error */
               }

       Read a private key from a BIO using the pass phrase
       "hello":

        key = PEM_read_bio_PrivateKey(bp, NULL, 0, "hello");
        if (key == NULL)
               {
               /* Error */
               }

       Read a private key from a BIO using a pass phrase call-
       back:

        key = PEM_read_bio_PrivateKey(bp, NULL, pass_cb, "My Private Key");
        if (key == NULL)
               {
               /* Error */
               }

       Skeleton pass phrase callback:

        int pass_cb(char *buf, int size, int rwflag, void *u);
               {
               int len;
               char *tmp;
               /* We'd probably do something else if 'rwflag' is 1 */
               printf("Enter pass phrase for \"%s\"\n", u);

               /* get pass phrase, length 'len' into 'tmp' */
               tmp = "hello";
               len = strlen(tmp);

               if (len <= 0) return 0;
               /* if too long, truncate */
               if (len > size) len = size;
               memcpy(buf, tmp, len);
               return len;
               }

NNOOTTEESS
       The old PPrriivvaatteeKKeeyy write routines are retained for compat-
       ibility.  New applications should write private keys using
       the _P_E_M___w_r_i_t_e___b_i_o___P_K_C_S_8_P_r_i_v_a_t_e_K_e_y_(_) or _P_E_M___w_r_i_t_e___P_K_C_S_8_P_r_i_-
       _v_a_t_e_K_e_y_(_) routines because they are more secure (they use
       an iteration count of 2048 whereas the traditional rou-
       tines use a count of 1) unless compatibility with older
       versions of OpenSSL is important.

       The PPrriivvaatteeKKeeyy read routines can be used in all applica-
       tions because they handle all formats transparently.



AerieBSD 1.0                2009-05-26                          8





PEM_READ_BIO_PRIVATEKEY(3)   OpenSSL   PEM_READ_BIO_PRIVATEKEY(3)


       A frequent cause of problems is attempting to use the PEM
       routines like this:

        X509 *x;
        PEM_read_bio_X509(bp, &x, 0, NULL);

       this is a bug because an attempt will be made to reuse the
       data at xx which is an uninitialised pointer.

PPEEMM EENNCCRRYYPPTTIIOONN FFOORRMMAATT
       This old PPrriivvaatteeKKeeyy routines use a non standard technique
       for encryption.

       The private key (or other data) takes the following form:

        -----BEGIN RSA PRIVATE KEY-----
        Proc-Type: 4,ENCRYPTED
        DEK-Info: DES-EDE3-CBC,3F17F5316E2BAC89

        ...base64 encoded data...
        -----END RSA PRIVATE KEY-----

       The line beginning DEK-Info contains two comma separated
       pieces of information: the encryption algorithm name as
       used by _E_V_P___g_e_t___c_i_p_h_e_r_b_y_n_a_m_e_(_) and an 8 byte ssaalltt encoded
       as a set of hexadecimal digits.

       After this is the base64 encoded encrypted data.

       The encryption key is determined using _E_V_P___b_y_t_e_s_t_o_k_e_y_(_),
       using ssaalltt and an iteration count of 1. The IV used is the
       value of ssaalltt and *not* the IV returned by
       _E_V_P___b_y_t_e_s_t_o_k_e_y_(_).

BBUUGGSS
       The PEM read routines in some versions of OpenSSL will not
       correctly reuse an existing structure. Therefore the fol-
       lowing:

        PEM_read_bio_X509(bp, &x, 0, NULL);

       where xx already contains a valid certificate, may not
       work, whereas:

        X509_free(x);
        x = PEM_read_bio_X509(bp, NULL, 0, NULL);

       is guaranteed to work.

RREETTUURRNN CCOODDEESS
       The read routines return either a pointer to the structure
       read or NULL if an error occurred.

       The write routines return 1 for success or 0 for failure.



AerieBSD 1.0                2009-05-26                          9


